\documentclass{article}

\usepackage{tikz} 
\usetikzlibrary{automata, positioning, arrows} 

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{color}
\usepackage{parskip}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\newtheoremstyle{theorem}
  {\topsep}   % ABOVESPACE
  {\topsep}   % BELOWSPACE
  {\itshape\/}  % BODYFONT
  {0pt}       % INDENT (empty value is the same as 0pt)
  {\bfseries} % HEADFONT
  {.}         % HEADPUNCT
  {5pt plus 1pt minus 1pt} % HEADSPACE
  {}          % CUSTOM-HEAD-SPEC
\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\title{CPSC-354 Report}
\author{Jack Mazac  \\ Chapman University}

\date{\today} 

\begin{document}

\maketitle

\begin{abstract}
This report chronicles the learning journey over the semester in CPSC-354. The course encompassed a diverse set of topics including formal systems, Lean theorem proving, and other key areas in computer science and logic. Throughout the semester, I engaged with a range of concepts, starting with an introduction to formal systems and basic Lean proofs, and gradually progressing to more complex topics. The report documents my notes, homework solutions, and critical reflections on the content covered each week. The goal is to provide a comprehensive overview of my understanding and development in these subjects.
\end{abstract}

\setcounter{tocdepth}{3}
\tableofcontents

\section{Introduction}\label{intro}

This report serves as a comprehensive documentation of my learning and development throughout the CPSC-354 course. The content spans from the basics of formal systems and Lean theorem proving to more advanced topics covered later in the semester. The report is structured week by week, with detailed notes, homework solutions, and reflections for each period. The aim is to capture both the technical and conceptual growth experienced over the course of the semester.

\section{Week 1}

\subsubsection*{Notes}

In Week 1, I explored the foundational concepts of formal systems through the MU-puzzle and began working with Lean proof tactics. The MU-puzzle introduced me to the idea of rule-based transformations within a formal system, emphasizing the importance of adhering strictly to the rules—known as the "Requirement of Formality." This concept was mirrored in my Lean exercises, where I learned to apply specific proof tactics to simplify and verify logical statements.

\subsubsection*{Homework}

The Lean tutorial levels 5 through 8 provided practical exercises that reinforced the theoretical concepts from the MU-puzzle. Below is a summary of the steps and lessons learned:

\subsubsection*{Level 5}
In Level 5, I learned how to handle simple arithmetic involving the addition of zero. The steps were as follows:
\begin{verbatim}
rw [add_zero]
rw [add_zero]
rfl
\end{verbatim}
This taught me the importance of simplifying expressions step by step and ensuring that both sides of an equation are identical before applying \texttt{rfl}.

\subsubsection*{Level 6}
Level 6 focused on precision rewriting. I applied the following steps:
\begin{verbatim}
rw [add_zero c]
rw [add_zero b]
rfl
\end{verbatim}
This exercise highlighted the need for targeted rewriting to simplify specific parts of an expression while maintaining overall accuracy.

\subsubsection*{Level 7}
In Level 7, I worked with the successor function and addition:
\begin{verbatim}
rw [succ_eq_add_one]
rfl
\end{verbatim}
This reinforced the relationship between successor functions and addition, showing how to simplify such expressions in Lean.

\subsubsection*{Level 8}
Level 8 was the most complex, requiring multiple rewrites to simplify nested successor functions:
\begin{verbatim}
rw [two_eq_succ_one]
rw [add_succ]
rw [one_eq_succ_zero]
rw [add_succ]
rw [add_zero]
rw [four_eq_succ_three]
rw [three_eq_succ_two]
rw [two_eq_succ_one]
rw [one_eq_succ_zero]
rfl
\end{verbatim}
This level emphasized the importance of meticulous, step-by-step simplifications, especially when dealing with Peano arithmetic.

\subsubsection*{Comments and Questions}

How do the abstract rules in formal systems like the MU-puzzle translate into practical applications in software engineering? 

\subsection{Week 2}

\ldots

\subsection{Lessons from the Assignments}

Throughout the semester, I encountered various challenges and learning opportunities that contributed to my understanding of formal systems, logic, and Lean theorem proving. Here are the key lessons:

\subsection{Precision and Structure in Formal Systems}

The early weeks of the course, particularly Week 1, emphasized the precision required when working within formal systems. The MU-puzzle illustrated how even simple rules can lead to complex problem-solving scenarios, mirroring the need for exactness in Lean proofs. As I progressed through the levels in Lean, this precision became even more critical, particularly when dealing with nested functions and arithmetic expressions.

\subsection{The Art of Rewriting in Lean}

Rewriting is a fundamental tactic in Lean, as demonstrated in Levels 5-8. The ability to identify which parts of an expression to rewrite—and in what order—can make the difference between a successful proof and a failed one. This process is not just mechanical; it involves a deep understanding of the underlying logical structure and the relationships between different components of an expression.

\subsection{Conclusion}\label{conclusion}

This course provided a rigorous exploration of formal systems and Lean theorem proving, both of which are foundational to understanding logic and formal reasoning in computer science.

\section{Week 2}

\subsubsection{Lecture Content}

In Week 2, we delved deeper into the Natural Number Game (NNG) and focused on the Addition World. The lectures covered the fundamental properties of addition for natural numbers and introduced us to more advanced proof techniques in Lean.

Key topics included:
\begin{itemize}
    \item Commutativity and associativity of addition
    \item The role of zero in addition
    \item Inductive proofs for properties of addition
    \item Tactics for rewriting and simplifying expressions in Lean
\end{itemize}

\subsubsection{NNG Addition World Solutions}

\paragraph{Levels 1-3: Lean Proofs}

\begin{lstlisting}
-- Level 1
rw [add_zero]

-- Level 2
rw [add_succ]
rw [succ_add]

-- Level 3
rw [succ_add]
rw [add_succ]
\end{lstlisting}

\paragraph{Level 4: Mathematical Proof}

\textbf{Theorem:} For all natural numbers a and b, a + succ(b) = succ(a + b)

\textbf{Proof:}
\begin{align*}
a + \text{succ}(b) &= \text{succ}(a + b) \quad [\text{by definition of +}]
\end{align*}

\paragraph{Level 5: Mathematical Proof}

\textbf{Theorem:} For all natural numbers n, 0 + n = n

\textbf{Proof:} By induction on n.

Base case: n = 0
\begin{align*}
0 + 0 &= 0 \quad [\text{by definition of +}]
\end{align*}

Inductive step: Assume 0 + k = k for some k. We need to prove 0 + succ(k) = succ(k).
\begin{align*}
0 + \text{succ}(k) &= \text{succ}(0 + k) \quad [\text{by definition of +}] \\
&= \text{succ}(k) \quad [\text{by inductive hypothesis}]
\end{align*}

Therefore, by mathematical induction, 0 + n = n for all natural numbers n.

\subsubsection{Relationship between Lean Proof and Mathematical Proof}

Let's examine the relationship between the Lean proof and the mathematical proof for Level 5:

Lean proof:
\begin{lstlisting}[language=Lean]
induction n with d hd
· rw [add_zero]
  rfl
· rw [add_succ]
  rw [hd]
  rfl
\end{lstlisting}

The Lean proof closely mirrors the structure of the mathematical induction proof:

1. \texttt{induction n with d hd} corresponds to setting up the induction on \(n\), with \(d\) representing the inductive variable and \texttt{hd} the inductive hypothesis.

2. The base case \texttt{rw [add\_zero]} followed by \texttt{rfl} reflects the mathematical step \(0 + 0 = 0\).

3. In the inductive step, \texttt{rw [add\_succ]} corresponds to expanding \(0 + \text{succ}(d)\) to \(\text{succ}(0 + d)\).

4. \texttt{rw [hd]} applies the inductive hypothesis, similar to using \(0 + k = k\) in the mathematical proof.

5. Finally, \texttt{rfl} completes the proof by asserting that the equality is now trivial, just as we conclude in the mathematical proof.

This comparison demonstrates how the rigorous structure of mathematical induction is encoded in Lean's tactics, providing a formal, machine-checkable version of the traditional proof.

\subsubsection{Interesting Question}

How does the use of induction in proving properties of natural numbers relate to recursive definitions in programming languages? Can we draw parallels between mathematical induction and recursive algorithms?

\section{Week 3}
\subsection{Parsing and Context-Free Grammars}
\subsubsection{Lecture Content}
In Week 3, we explored the concepts of parsing and context-free grammars (CFGs). The lectures covered the following key topics:
\begin{itemize}
\item Translating concrete syntax into abstract syntax
\item The role of parsing in programming languages
\item Defining the concrete syntax of a calculator using a CFG
\item Writing a CFG using the Lark parser generator
\item Generating a parser in Python to translate concrete arithmetic expressions to abstract ones
\end{itemize}
\subsubsection{Homework Solutions}
\paragraph{Derivation Trees}
Using the provided context-free grammar, here are the derivation trees for the given strings:
2+1:
\begin{verbatim}
Exp
|
Exp '+' Exp1
|       |
Exp1     Exp2
|       |
Exp2   Integer
|       |
Integer    '1'
|
'2'
\end{verbatim}
1+23:
\begin{verbatim}
Exp
|
Exp '+' Exp1
|       |
Exp1   Exp1 '' Exp2
|       |       |
Exp2    Exp2   Integer
|       |       |
Integer  Integer   '3'
|       |
'1'    '2'
\end{verbatim}
1+(23):
\begin{verbatim}
Exp
|
Exp '+' Exp1
|       |
Exp1    Exp2
|       |
Exp2   '(' Exp ')'
|       |   |
Integer    Exp1 '' Exp2
|       |       |
'1'    Exp2   Integer
|       |
Integer    '3'
|
'2'
\end{verbatim}
(1+2)3:
\begin{verbatim}
Exp
|
Exp1 '' Exp2
|        |
Exp2    Integer
|        |
'(' Exp ')'  '3'
|
Exp '+' Exp1
|       |
Exp1     Exp2
|       |
Exp2   Integer
|       |
Integer    '2'
|
'1'
\end{verbatim}
1+23+45+6:
\begin{verbatim}
Exp
|
Exp '+' Exp1
|       |
Exp '+' Exp1 Exp2
|       |     |
Exp1 Exp1 '' Exp2 Integer
|     |       |     |
Exp2  Exp2   Integer '6'
|     |       |
Integer Integer   '5'
|     |
'1'  '2' '' Exp2
|
Exp2
|
Integer
|
'3' '+' Exp1
|
Exp1 '*' Exp2
|       |
Exp2   Integer
|       |
Integer    '4'
|
'3'
\end{verbatim}
\paragraph{Similarities and Differences between CFG and Algebraic Data Type}
The CFG and algebraic data type for expressions share some similarities:
\begin{itemize}
\item Both define the structure of valid expressions
\item Both capture the precedence of operations (e.g., multiplication before addition)
\item Both can be used to generate or recognize valid expressions
\end{itemize}
However, there are also some key differences:
\begin{itemize}
\item The CFG is used for parsing, i.e., translating concrete syntax (strings) into an abstract syntax tree (AST), while the algebraic data type directly defines the structure of the AST
\item The CFG is a set of production rules, while the algebraic data type is a type definition with constructors
\item The CFG can include redundant rules or ambiguity, while the algebraic data type is more precise and concise
\end{itemize}
\subsubsection{Interesting Questions}
\begin{itemize}
\item How can we extend the calculator CFG to handle more advanced features like variables, functions, or control structures?
\item What are some real-world applications of parsing beyond programming languages (e.g., natural language processing, data serialization formats)?
\item How do more advanced parsing techniques like parser combinators or parsing expression grammars compare to traditional CFG-based parsing?
\end{itemize}

\section{Week 5}

\subsection{Level 1: Assumption}
If $P$, then $P$.

Proof:
\begin{enumerate}
    \item $P$ \hfill assumption
\end{enumerate}

\subsection{Level 2: Constructor}
If $P$ and $Q$, then $P \wedge Q$.

Proof:
\begin{enumerate}
    \item $P$ \hfill assumption
    \item $Q$ \hfill assumption
    \item $P \wedge Q$ \hfill and\_intro (1) (2)
\end{enumerate}

\subsection{Level 3: Practice Makes Perfect}
If $P$, $Q$, $R$, and $S$, then $(P \wedge Q) \wedge R \wedge S$.

Proof:
\begin{enumerate}
    \item $P$ \hfill assumption
    \item $Q$ \hfill assumption
    \item $R$ \hfill assumption
    \item $S$ \hfill assumption
    \item $P \wedge Q$ \hfill and\_intro (1) (2)
    \item $(P \wedge Q) \wedge R$ \hfill and\_intro (5) (3)
    \item $(P \wedge Q) \wedge R \wedge S$ \hfill and\_intro (6) (4)
\end{enumerate}

\subsection{Level 4: Cases for a Conjunction}
If $P \wedge Q$, then $P$.

Proof:
\begin{enumerate}
    \item $P \wedge Q$ \hfill assumption
    \item $P$ \hfill and\_left (1)
\end{enumerate}

\subsection{Level 5: Rinse and Repeat}
If $P \wedge Q$, then $Q$.

Proof:
\begin{enumerate}
    \item $P \wedge Q$ \hfill assumption
    \item $Q$ \hfill and\_right (1)
\end{enumerate}

\subsection{Level 6: Nothing New}
If $P \wedge Q$ and $R \wedge S$, then $P \wedge S$.

Proof:
\begin{enumerate}
    \item $P \wedge Q$ \hfill assumption
    \item $R \wedge S$ \hfill assumption
    \item $P$ \hfill and\_left (1)
    \item $S$ \hfill and\_right (2)
    \item $P \wedge S$ \hfill and\_intro (3) (4)
\end{enumerate}

\subsection{Level 7: So Many Cases}
If $(Q \wedge (((Q \wedge P) \wedge Q) \wedge Q \wedge Q \wedge Q)) \wedge (Q \wedge Q) \wedge Q$, then $P$.

Proof:
\begin{enumerate}
    \item $(Q \wedge (((Q \wedge P) \wedge Q) \wedge Q \wedge Q \wedge Q)) \wedge (Q \wedge Q) \wedge Q$ \hfill assumption
    \item $Q \wedge (((Q \wedge P) \wedge Q) \wedge Q \wedge Q \wedge Q)$ \hfill and\_left (1)
    \item $((Q \wedge P) \wedge Q) \wedge Q \wedge Q \wedge Q$ \hfill and\_right (2)
    \item $(Q \wedge P) \wedge Q$ \hfill and\_left (3)
    \item $Q \wedge P$ \hfill and\_left (4)
    \item $P$ \hfill and\_right (5)
\end{enumerate}

\subsection{Level 8: BOSS LEVEL}
If $((P \wedge S) \wedge A) \wedge \neg I \wedge (C \wedge \neg O) \wedge \neg U$, then $A \wedge C \wedge P \wedge S$.

Proof:
\begin{enumerate}
    \item $((P \wedge S) \wedge A) \wedge \neg I \wedge (C \wedge \neg O) \wedge \neg U$ \hfill assumption
    \item $(P \wedge S) \wedge A$ \hfill and\_left (1)
    \item $P \wedge S$ \hfill and\_left (2)
    \item $A$ \hfill and\_right (2)
    \item $P$ \hfill and\_left (3)
    \item $S$ \hfill and\_right (3)
    \item $\neg I \wedge (C \wedge \neg O) \wedge \neg U$ \hfill and\_right (1)
    \item $C \wedge \neg O$ \hfill and\_left (and\_right (7))
    \item $C$ \hfill and\_left (8)
    \item $A \wedge C$ \hfill and\_intro (4) (9)
    \item $(A \wedge C) \wedge P$ \hfill and\_intro (10) (5)
    \item $A \wedge C \wedge P \wedge S$ \hfill and\_intro (11) (6)
\end{enumerate}

\section{Week 6}

\subsection{Level 1: Let there be cake!}
\textbf{Theorem:} If P → C and P, then C.

\textbf{Proof:}
\begin{enumerate}
    \item P \hfill assumption
    \item P → C \hfill assumption
    \item C \hfill modus ponens (1, 2)
\end{enumerate}

\subsection{Level 2: Is it Cake!?}
\textbf{Theorem:} C → C

\textbf{Proof:}
\begin{enumerate}
    \item Assume C \hfill assumption
    \item C \hfill (1)
    \item C → C \hfill (1-2, →-introduction)
\end{enumerate}

\subsection{Level 3: Trouble with the cake}
\textbf{Theorem:} I ∧ S → S ∧ I

\textbf{Proof:}
\begin{enumerate}
    \item Assume I ∧ S \hfill assumption
    \item I \hfill and-elimination left (1)
    \item S \hfill and-elimination right (1)
    \item S ∧ I \hfill and-introduction (3, 2)
    \item (I ∧ S) → (S ∧ I) \hfill (1-4, →-introduction)
\end{enumerate}

\subsection{Level 4: Transitivity Aside}
\textbf{Theorem:} If C → A and A → S, then C → S.

\textbf{Proof:}
\begin{enumerate}
    \item C → A \hfill assumption
    \item A → S \hfill assumption
    \item Assume C \hfill assumption
    \item A \hfill modus ponens (3, 1)
    \item S \hfill modus ponens (4, 2)
    \item C → S \hfill (3-5, →-introduction)
\end{enumerate}

\subsection{Level 5: then the quest has begun}
\textbf{Theorem:} If P → Q, Q → R, Q → T, S → T, T → U, and P, then U.

\textbf{Proof:}
\begin{enumerate}
    \item P \hfill assumption
    \item P → Q \hfill assumption
    \item Q → R \hfill assumption
    \item Q → T \hfill assumption
    \item S → T \hfill assumption
    \item T → U \hfill assumption
    \item Q \hfill modus ponens (1, 2)
    \item T \hfill modus ponens (7, 4)
    \item U \hfill modus ponens (8, 6)
\end{enumerate}

\subsection{Level 6: Curry}
\textbf{Theorem:} If C ∧ D → S, then C → (D → S).

\textbf{Proof:}
\begin{enumerate}
    \item C ∧ D → S \hfill assumption
    \item Assume C \hfill assumption
    \item Assume D \hfill assumption
    \item C ∧ D \hfill and-introduction (2, 3)
    \item S \hfill modus ponens (4, 1)
    \item D → S \hfill (3-5, →-introduction)
    \item C → (D → S) \hfill (2-6, →-introduction)
\end{enumerate}

\subsection{Level 7: Un-Curry}
\textbf{Theorem:} If C → (D → S), then C ∧ D → S.

\textbf{Proof:}
\begin{enumerate}
    \item C → (D → S) \hfill assumption
    \item Assume C ∧ D \hfill assumption
    \item C \hfill and-elimination left (2)
    \item D \hfill and-elimination right (2)
    \item D → S \hfill modus ponens (3, 1)
    \item S \hfill modus ponens (4, 5)
    \item C ∧ D → S \hfill (2-6, →-introduction)
\end{enumerate}

\subsection{Level 8: Go buy chips and dip!}
\textbf{Theorem:} If (S → C) ∧ (S → D), then S → (C ∧ D).

\textbf{Proof:}
\begin{enumerate}
    \item (S → C) ∧ (S → D) \hfill assumption
    \item S → C \hfill and-elimination left (1)
    \item S → D \hfill and-elimination right (1)
    \item Assume S \hfill assumption
    \item C \hfill modus ponens (4, 2)
    \item D \hfill modus ponens (4, 3)
    \item C ∧ D \hfill and-introduction (5, 6)
    \item S → (C ∧ D) \hfill (4-7, →-introduction)
\end{enumerate}

\subsection{Level 9: Riffin and Sybeth}
\textbf{Theorem:} R → ((S → R) ∧ (¬S → R))

\textbf{Proof:}
\begin{enumerate}
    \item Assume R \hfill assumption
    \item Assume S \hfill assumption
    \item R \hfill (1)
    \item S → R \hfill (2-3, →-introduction)
    \item Assume ¬S \hfill assumption
    \item R \hfill (1)
    \item ¬S → R \hfill (5-6, →-introduction)
    \item (S → R) ∧ (¬S → R) \hfill and-introduction (4, 7)
    \item R → ((S → R) ∧ (¬S → R)) \hfill (1-8, →-introduction)
\end{enumerate}


\section{Week 7}
\textbf{Part 1: Reduction of the Lambda Term}

We will reduce the given lambda term step by step using beta reductions while avoiding variable capture.

\textbf{Steps:}

1. \[
\left( \lambda m.\ \lambda n.\ m\ n \right)\ \left( \lambda f.\ \lambda x.\ f\ (f\ x) \right)\ \left( \lambda f.\ \lambda x.\ f\ \left( f\ \left( f\ x \right) \right) \right)
\]

2. \[
\left( \lambda n.\ \left( \lambda f.\ \lambda x.\ f\ (f\ x) \right)\ n \right)\ \left( \lambda f.\ \lambda x.\ f\ \left( f\ \left( f\ x \right) \right) \right)
\]

3. \[
\left( \lambda f.\ \lambda x.\ f\ (f\ x) \right)\ \left( \lambda f.\ \lambda x.\ f\ \left( f\ \left( f\ x \right) \right) \right)
\]

4. \[
\lambda x.\ \left( \lambda f.\ \lambda x.\ f\ (f\ x) \right)\ \left( \lambda f.\ \lambda x.\ f\ \left( f\ \left( f\ x \right) \right) \right)\ x
\]

5. \[
\lambda x.\ \left( \left( \lambda f.\ \lambda x.\ f\ (f\ x) \right)\ \left( \lambda y.\ \left( f\ \left( f\ \left( f\ y \right) \right) \right) \right) \right)\ x
\]

6. \[
\lambda x.\ \left( \lambda z.\ \left( \lambda y.\ f\ (f\ y) \right)\ \left( f\ \left( f\ \left( f\ z \right) \right) \right) \right)\ x
\]

7. \[
\lambda x.\ \left( \lambda z.\ f\ \left( f\ \left( f\ \left( f\ \left( f\ \left( f\ \left( f\ \left( f\ \left( f\ z \right) \right) \right) \right) \right) \right) \right) \right) \right)\ x
\]

\textbf{Part 2: Function Implemented by \(\lambda m.\ \lambda n.\ m\ n\)}

In \textbf{Part 1}, we start by applying the first lambda function to its argument:

1. The term \(\left( \lambda m.\ \lambda n.\ m\ n \right)\) is applied to \(\left( \lambda f.\ \lambda x.\ f\ (f\ x) \right)\), resulting in \(\lambda n.\ \left( \lambda f.\ \lambda x.\ f\ (f\ x) \right)\ n\).

2. Next, we apply this result to \(\left( \lambda f.\ \lambda x.\ f\ \left( f\ \left( f\ x \right) \right) \right)\), giving \(\left( \lambda f.\ \lambda x.\ f\ (f\ x) \right)\ \left( \lambda f.\ \lambda x.\ f\ \left( f\ \left( f\ x \right) \right) \right)\).

3. We then substitute \(\left( \lambda f.\ \lambda x.\ f\ \left( f\ \left( f\ x \right) \right) \right)\) for \(f\) in the function, resulting in \(\lambda x.\ \left( \lambda f.\ \lambda x.\ f\ (f\ x) \right)\ \left( \lambda f.\ \lambda x.\ f\ \left( f\ \left( f\ x \right) \right) \right)\ x\).

4. Continuing the substitutions and reducing, we eventually reach a term where the function \(f\) is applied nine times to \(x\): \(\lambda x.\ f^{9}\ x\).

This final term represents the Church numeral for 9, showing that the original expression computes \(3^2 = 9\) when using Church numerals for 2 and 3.

In \textbf{Part 2}, the function \(\lambda m.\ \lambda n.\ m\ n\) takes two Church numerals \(m\) and \(n\) and applies \(m\) to \(n\). In the context of Church numerals, this operation corresponds to exponentiation. Specifically, it computes \(n\) raised to the power of \(m\), since applying \(m\) to \(n\) results in \(n\) being applied \(m\) times.


\section{Week 8 - 9}

\subsection{Running Tests and Adding New Test Cases}

We begin by running the provided tests in \texttt{interpreter\_test.py} to ensure that the interpreter is functioning correctly.

\subsubsection{Running the Existing Tests}

The existing tests can be run using the following command:

\begin{verbatim}
python interpreter_test.py
\end{verbatim}

The output confirms that all tests pass:

\begin{verbatim}
Python version: 3.10.9 (main, Jan 11 2023, 09:18:20) [Clang 14.0.6 ]
Lark version: 1.1.9

TEST PARSING

AST x == ('var', 'x')
AST (((x)) ((y))) == ('app', ('var', 'x'), ('var', 'y'))
AST x y == ('app', ('var', 'x'), ('var', 'y'))
AST x y z == ('app', ('app', ('var', 'x'), ('var', 'y')), ('var', 'z'))
AST \x.y == ('lam', 'x', ('var', 'y'))
AST \x.x y == ('lam', 'x', ('app', ('var', 'x'), ('var', 'y')))
AST \x.x y z == ('lam', 'x', ('app', ('app', ('var', 'x'), ('var', 'y')), ('var', 'z')))
AST \x. \y. \z. x y z == ('lam', 'x', ('lam', 'y', ('lam', 'z', ('app', ('app', ('var', 'x'), ('var', 'y')), ('var', 'z')))))
AST \x. x a == ('lam', 'x', ('app', ('var', 'x'), ('var', 'a')))
AST \x. x (\y. y) == ('lam', 'x', ('app', ('var', 'x'), ('lam', 'y', ('var', 'y'))))
AST \x. x (\y. y (\z. z z2)) == ('lam', 'x', ('app', ('var', 'x'), ('lam', 'y', ('app', ('var', 'y'), ('lam', 'z', ('app', ('var', 'z'), ('var', 'z2')))))))
AST \x. y z (\a. b (\c. d e f)) == ('lam', 'x', ('app', ('app', ('var', 'y'), ('var', 'z')), ('lam', 'a', ('app', ('var', 'b'), ('lam', 'c', ('app', ('app', ('var', 'd'), ('var', 'e')), ('var', 'f')))))))

Parser: All tests passed!


TEST SUBSTITUTION

SUBST x [y/x] == ('var', 'y')
SUBST \x.x [y/x] == ('lam', 'x', ('var', 'x'))
SUBST (x x) [y/x] == ('app', ('var', 'y'), ('var', 'y'))
SUBST \y. x [y/x] == ('lam', 'Var1', ('var', 'y'))

substitute(): All tests passed!


TEST EVALUATION

EVAL x == x
EVAL x y == (x y)
EVAL x y z == ((x y) z)
EVAL x (y z) == (x (y z))
EVAL \x.y == \x.y
EVAL (\x.x) y == y

evaluate(): All tests passed!


TEST INTERPRETATION

Testing x --> x
Testing x y --> (x y)
Testing \x.x --> (\x.x)
Testing (\x.x) y --> y
Testing (\x.\y.x y) y --> (\Var2.(y Var2))

interpret(): All tests passed!
\end{verbatim}

\subsubsection{Adding New Test Cases}

We have added a new test case to each function in \texttt{interpreter\_test.py} to further verify the interpreter's correctness.

\paragraph{Test Parsing}

In the \texttt{test\_parse()} function, we added:

\begin{verbatim}
assert ast(r"(\x.x) (\y.y)") == ('app', ('lam', 'x', ('var', 'x')), ('lam', 'y', ('var', 'y')))
print(f"AST {MAGENTA}(\\x.x) (\\y.y){RESET} == ('app', ('lam', 'x', ('var', 'x')), ('lam', 'y', ('var', 'y')))")
\end{verbatim}

This tests parsing of an application of two lambda abstractions.

\paragraph{Test Substitution}

In the \texttt{test\_substitute()} function, we added:

\begin{verbatim}
# SUBST (\x.x y) [y/z] == (\Var1.Var1 y)
assert substitute(('lam', 'x', ('app', ('var', 'x'), ('var', 'y'))), 'y', ('var', 'z')) == ('lam', 'Var1', ('app', ('var', 'Var1'), ('var', 'z')))
print(f"SUBST {MAGENTA}\\x.x y [z/y]{RESET} == ('lam', 'Var1', ('app', ('var', 'Var1'), ('var', 'z')))")
\end{verbatim}

This tests substitution where the variable to be substituted is free in the body.

\paragraph{Test Evaluation}

In the \texttt{test\_evaluate()} function, we added:

\begin{verbatim}
# EVAL (\x.\y.x y) a b == (a b)
assert linearize(evaluate(ast(r"(\x.\y.x y) a b"))) == "(a b)"
print(f"EVAL {MAGENTA}(\\x.\\y.x y) a b{RESET} == (a b)")
\end{verbatim}

This tests evaluation of nested lambda abstractions with applications.

\paragraph{Test Interpretation}

In the \texttt{test\_interpret()} function, we added:

\begin{verbatim}
input=r"(\x.\y.y x) a b"; output = interpret(input); print(f"Testing {input} --> {output}")
\end{verbatim}

Which outputs:

\begin{verbatim}
Testing (\x.\y.y x) a b --> (b a)
\end{verbatim}

\subsection{Running New Test Cases}

After adding the new test cases, we run the tests again:

\begin{verbatim}
python interpreter_test.py
\end{verbatim}

The tests pass, confirming that our additions are correct.

\subsection{Adding Programs to \texttt{test.lc} and Running the Interpreter}

\label{sec:testlc}

We added the following lambda calculus expressions to \texttt{test.lc}:

\begin{verbatim}
-- Identity function applied to itself
(\x.x) (\x.x)

-- Function that applies its argument to itself
(\x.x x) (\x.x x)

-- Combinator K (\x.\y.x)
(\x.\y.x) a b

-- Combinator S (\x.\y.\z.x z (y z))
(\x.\y.\z.((x z) (y z))) a b c
\end{verbatim}

We run the interpreter with:

\begin{verbatim}
python interpreter.py test.lc
\end{verbatim}

The interpreter outputs the results for each expression:

\begin{verbatim}
(\x.x)
((\x.x x) (\x.x x))
a
((a c) (b c))
\end{verbatim}

\subsection{Reduction of Expressions}

\paragraph{Reduction of \texttt{a b c d}}

The expression \texttt{a b c d} reduces as follows:

\begin{align*}
a\ b\ c\ d &= (((a\ b)\ c)\ d)
\end{align*}

This is due to the left-associative nature of function application in lambda calculus. Each application groups to the left.

\paragraph{Reduction of \texttt{(a)}}

The expression \texttt{(a)} reduces to \texttt{a} because the parentheses are just grouping symbols and do not affect the evaluation.

\subsection{Capture-Avoiding Substitution}

Capture-avoiding substitution ensures that when substituting an expression for a variable, we do not accidentally change the meaning of the expression by capturing free variables.

\paragraph{Implementation}

In \texttt{interpreter.py}, substitution is implemented in the \texttt{substitute()} function. When substituting into a lambda abstraction, if the bound variable is the same as the variable we are substituting for, we leave the abstraction unchanged. If there is a potential for variable capture, we generate a fresh variable name using the \texttt{NameGenerator} class.

\begin{verbatim}
elif tree[0] == 'lam':
    if tree[1] == name:
        return tree  # Variable bound; do not substitute
    else:
        fresh_name = name_generator.generate()
        new_body = substitute(tree[2], tree[1], ('var', fresh_name))
        return ('lam', fresh_name, substitute(new_body, name, replacement))
\end{verbatim}

\paragraph{Test Cases}

We tested this with the following expression:

\begin{verbatim}
SUBST \y. x y [y/x] == (\Var1. (y Var1))
\end{verbatim}

This shows that when substituting \texttt{y} for \texttt{x} in \texttt{\y. x y}, we avoid capturing the variable \texttt{y} by renaming the bound variable to \texttt{Var1}.

\subsection{Normal Form and Non-Terminating Expressions}

\paragraph{Do All Computations Reduce to Normal Form?}

Not all lambda calculus expressions reduce to a normal form due to the possibility of infinite reductions. For example, the following expression does not reduce to a normal form:

\begin{verbatim}
(\x. x x) (\x. x x)
\end{verbatim}

\paragraph{Minimal Working Example}

The smallest lambda expression that does not reduce to normal form is the self-application of the identity function to itself:

\begin{verbatim}
(\x. x x) (\x. x x)
\end{verbatim}

This expression causes infinite recursion during evaluation.

\subsection{Using the Debugger to Trace Executions}

\paragraph{Setting Up the Debugger}

To trace the execution of the interpreter, we set breakpoints in \texttt{interpreter.py} at the calls to \texttt{evaluate()} and \texttt{substitute()}.

\paragraph{Tracing the Evaluation}

We input the expression:

\begin{verbatim}
((\m.\n. m n) (\f.\x. f (f x))) (\f.\x. f x)
\end{verbatim}

By stepping through the interpreter, we observe the following calls to \texttt{evaluate()} and \texttt{substitute()}:

\begin{verbatim}
evaluate(('app',
          ('app',
           ('lam', 'm', ('lam', 'n', ('app', ('var', 'm'), ('var', 'n')))),
           ('lam', 'f', ('lam', 'x', ('app', ('var', 'f'), ('app', ('var', 'f'), ('var', 'x')))))),
          ('lam', 'f', ('lam', 'x', ('app', ('var', 'f'), ('var', 'x'))))))
evaluate(('app',
          ('lam', 'm', ('lam', 'n', ('app', ('var', 'm'), ('var', 'n')))),
          ('lam', 'f', ('lam', 'x', ('app', ('var', 'f'), ('app', ('var', 'f'), ('var', 'x')))))))
evaluate(('lam', 'm', ('lam', 'n', ('app', ('var', 'm'), ('var', 'n')))))
substitute(('lam', 'n', ('app', ('var', 'm'), ('var', 'n'))), 'm', ('lam', 'f', ('lam', 'x', ('app', ('var', 'f'), ('app', ('var', 'f'), ('var', 'x'))))))
...
\end{verbatim}

\paragraph{Understanding the Evaluation Strategy}

By following the recursive calls and substitutions, we see how the interpreter applies beta reduction and maintains variable bindings without capture.

\subsection{Implementation Challenges and Solutions}

Throughout the development of our lambda calculus interpreter, we encountered several challenges that required careful consideration and innovative solutions. This section outlines these issues, our approach to solving them, and the final implementation.

\paragraph{Issues Encountered}

\begin{enumerate}
    \item \textbf{Infinite Recursion:} Initially, the interpreter would enter infinite recursion when evaluating non-terminating expressions like $(\lambda x.x x) (\lambda x.x x)$ (the omega combinator). This caused stack overflow errors.
    \item \textbf{Depth Limitation Ineffectiveness:} We attempted to solve the infinite recursion problem by introducing a maximum evaluation depth (\texttt{MAX\_EVAL\_DEPTH}). However, this approach was not effective as the recursion error persisted in the \texttt{substitute} function.
    \item \textbf{Stack Overflow in Recursive Approach:} The recursive implementation of both \texttt{evaluate} and \texttt{substitute} functions led to stack overflow errors for deeply nested expressions or non-terminating computations.
    \item \textbf{IndexError in Iterative Approach:} When we switched to an iterative approach for \texttt{substitute}, we encountered an IndexError due to attempting to pop from an empty list. This occurred because the stack management in the substitute function was not robust enough to handle all cases.
    \item \textbf{Partial Evaluation of Non-terminating Expressions:} While not strictly an "issue," we had to decide how to handle non-terminating expressions. The initial solution returned partially evaluated expressions when the maximum number of iterations was reached.
\end{enumerate}

\paragraph{Solutions Implemented}

To address these issues, we implemented the following solutions:

\begin{enumerate}
    \item \textbf{Iterative Approach:} We replaced the recursive implementations of \texttt{evaluate} and \texttt{substitute} with iterative versions to avoid stack overflow errors.
    \item \textbf{Maximum Iterations:} We introduced a \texttt{MAX\_ITERATIONS} constant to limit the number of reduction steps and prevent infinite loops while allowing for deep evaluations.
    \item \textbf{Robust Stack Management:} We improved the stack management in the \texttt{substitute} function to handle all cases without errors, using separate stacks for the traversal and the result building.
    \item \textbf{Graceful Handling of Non-terminating Expressions:} The interpreter now returns partially evaluated expressions for non-terminating computations, allowing it to handle a wider range of expressions without crashing.
    \item \textbf{Separate Processing of Expressions:} We modified the main loop to process each expression separately, allowing the interpreter to continue even if one expression doesn't terminate.
\end{enumerate}

\paragraph{Final Implementation}

The final implementation of our lambda calculus interpreter incorporates these solutions, resulting in a robust and flexible tool. Key features of the final implementation include:

\begin{itemize}
    \item \textbf{Iterative Evaluation:} The \texttt{evaluate} function uses a while loop with a counter to prevent infinite loops:
    
    \begin{verbatim}
    def evaluate(tree):
        iterations = 0
        while iterations < MAX_ITERATIONS:
            if tree[0] == 'app':
                # ... (evaluation logic)
            else:
                return tree
            iterations += 1
        return tree  # Return partially evaluated tree if max iterations reached
    \end{verbatim}
    
    \item \textbf{Iterative Substitution:} The \texttt{substitute} function uses an explicit stack for traversal and a result stack for building the substituted expression:
    
    \begin{verbatim}
    def substitute(tree, name, replacement):
        stack = [(tree, False)]
        result_stack = []
        
        while stack:
            # ... (substitution logic)
        
        if result_stack:
            return result_stack[0]
        else:
            return tree  # Return original tree if no substitution occurred
    \end{verbatim}
    
    \item \textbf{Flexible Expression Handling:} The main function processes each expression in the input file separately:
    
    \begin{verbatim}
    def main():
        # ... (file reading logic)
        for expression in expressions:
            if expression.strip() and not expression.strip().startswith('--'):
                result = interpret(expression)
                print(f"Expression: {expression}")
                print(f"Result: \033[95m{result}\033[0m")
                print()
    \end{verbatim}
\end{itemize}

This implementation successfully handles both terminating and non-terminating expressions, providing a balance between functionality and preventing infinite computations. It demonstrates the practical application of theoretical concepts in lambda calculus while addressing real-world programming challenges.

\section{Detailed Evaluation of Complex Expressions}

To better understand how the interpreter handles complex expressions, we'll examine the evaluation of:

\begin{verbatim}
((\m.\n. m n) (\f.\x. f (f x))) (\f.\x. f (f (f x)))
\end{verbatim}

The evaluation proceeds as follows:

\begin{enumerate}
    \item The outermost application is evaluated first.
    \item The left part (\texttt{(\m.\n. m n) (\f.\x. f (f x))}) is evaluated:
        \begin{itemize}
            \item \texttt{m} is substituted with \texttt{(\f.\x. f (f x))}
            \item This results in \texttt{(\n. (\f.\x. f (f x)) n)}
        \end{itemize}
    \item The result is applied to \texttt{(\f.\x. f (f (f x)))}:
        \begin{itemize}
            \item \texttt{n} is substituted with \texttt{(\f.\x. f (f (f x)))}
            \item This yields \texttt{(\f.\x. f (f x)) (\f.\x. f (f (f x)))}
        \end{itemize}
    \item The final beta-reduction occurs:
        \begin{itemize}
            \item \texttt{f} is substituted with \texttt{(\x. f (f (f x)))}
            \item The result is \texttt{(\x. (\x. f (f (f x))) ((\x. f (f (f x))) x))}
        \end{itemize}
\end{enumerate}

This evaluation demonstrates how the interpreter handles nested lambda abstractions and applications.

\section{Tracing Recursive Calls}

To gain insight into the evaluation strategy, we trace the recursive calls to \texttt{evaluate()} for the expression:

\begin{verbatim}
((\m.\n. m n) (\f.\x. f (f x))) (\f.\x. f x)
\end{verbatim}

The trace would show the sequence of \texttt{evaluate()} and \texttt{substitute()} calls, illustrating how the interpreter traverses the expression tree and applies beta-reductions. Due to the iterative nature of our final implementation, the trace would show a series of iterations within the \texttt{evaluate()} function, each handling a part of the expression until the final result is reached or the maximum number of iterations is hit.

\paragraph{Handling the Minimal Working Example (MWE)}

The Minimal Working Example (MWE) that does not reduce to normal form is:

\begin{verbatim}
(\x. x x) (\x. x x)
\end{verbatim}

Our modified interpreter handles this expression by:

\begin{enumerate}
    \item The interpreter begins evaluating the expression.
    \item It applies beta-reduction, substituting \texttt{(\x. x x)} for \texttt{x} in the body of the first lambda.
    \item This results in \texttt{(\x. x x) (\x. x x)}, which is identical to the starting expression.
    \item The process repeats until MAX\_ITERATIONS is reached.
    \item The interpreter returns the partially evaluated expression, preventing an infinite loop.
\end{enumerate}

\subsection{Conclusion}

Through this project, we've implemented a lambda calculus interpreter that balances theoretical correctness with practical considerations. Key achievements include:

\begin{itemize}
    \item Implementing capture-avoiding substitution.
    \item Handling both terminating and non-terminating expressions.
    \item Using an iterative approach to prevent stack overflow.
    \item Providing a flexible tool for experimenting with lambda calculus.
\end{itemize}

The interpreter demonstrates the challenges of implementing theoretical concepts in practice and showcases solutions to common issues like infinite recursion and variable capture. It serves as a valuable educational tool for understanding lambda calculus and interpreter design.

\subsection{Question}

The Minimal Working Example (MWE) in our \texttt{test.lc} file, \texttt{(\x.x x) (\x.x x)}, is a non-terminating expression that demonstrates a form of recursion. How does this relate to the Y combinator and fixed point combinators in lambda calculus? How might we extend our interpreter to support more complex recursive structures while still managing potential non-termination?

\begin{thebibliography}{9}
\bibitem{lambda} Henk Barendregt, \emph{The Lambda Calculus: Its Syntax and Semantics}, North-Holland, 1984.
\end{thebibliography}

\end{document}


\end{document}
