\documentclass{article}

\usepackage{tikz} 
\usetikzlibrary{automata, positioning, arrows} 

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{color}
\usepackage{parskip}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\newtheoremstyle{theorem}
  {\topsep}   % ABOVESPACE
  {\topsep}   % BELOWSPACE
  {\itshape\/}  % BODYFONT
  {0pt}       % INDENT (empty value is the same as 0pt)
  {\bfseries} % HEADFONT
  {.}         % HEADPUNCT
  {5pt plus 1pt minus 1pt} % HEADSPACE
  {}          % CUSTOM-HEAD-SPEC
\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\title{CPSC-354 Report}
\author{Jack Mazac  \\ Chapman University}

\date{\today} 

\begin{document}

\maketitle

\begin{abstract}
This report chronicles the learning journey over the semester in CPSC-354. The course encompassed a diverse set of topics including formal systems, Lean theorem proving, and other key areas in computer science and logic. Throughout the semester, I engaged with a range of concepts, starting with an introduction to formal systems and basic Lean proofs, and gradually progressing to more complex topics. The report documents my notes, homework solutions, and critical reflections on the content covered each week. The goal is to provide a comprehensive overview of my understanding and development in these subjects.
\end{abstract}

\setcounter{tocdepth}{3}
\tableofcontents

\section{Introduction}\label{intro}

This report serves as a comprehensive documentation of my learning and development throughout the CPSC-354 course. The content spans from the basics of formal systems and Lean theorem proving to more advanced topics covered later in the semester. The report is structured week by week, with detailed notes, homework solutions, and reflections for each period. The aim is to capture both the technical and conceptual growth experienced over the course of the semester.

\section{Week 1}

\subsubsection*{Notes}

In Week 1, I explored the foundational concepts of formal systems through the MU-puzzle and began working with Lean proof tactics. The MU-puzzle introduced me to the idea of rule-based transformations within a formal system, emphasizing the importance of adhering strictly to the rules—known as the "Requirement of Formality." This concept was mirrored in my Lean exercises, where I learned to apply specific proof tactics to simplify and verify logical statements.

\subsubsection*{Homework}

The Lean tutorial levels 5 through 8 provided practical exercises that reinforced the theoretical concepts from the MU-puzzle. Below is a summary of the steps and lessons learned:

\subsubsection*{Level 5}
In Level 5, I learned how to handle simple arithmetic involving the addition of zero. The steps were as follows:
\begin{verbatim}
rw [add_zero]
rw [add_zero]
rfl
\end{verbatim}
This taught me the importance of simplifying expressions step by step and ensuring that both sides of an equation are identical before applying \texttt{rfl}.

\subsubsection*{Level 6}
Level 6 focused on precision rewriting. I applied the following steps:
\begin{verbatim}
rw [add_zero c]
rw [add_zero b]
rfl
\end{verbatim}
This exercise highlighted the need for targeted rewriting to simplify specific parts of an expression while maintaining overall accuracy.

\subsubsection*{Level 7}
In Level 7, I worked with the successor function and addition:
\begin{verbatim}
rw [succ_eq_add_one]
rfl
\end{verbatim}
This reinforced the relationship between successor functions and addition, showing how to simplify such expressions in Lean.

\subsubsection*{Level 8}
Level 8 was the most complex, requiring multiple rewrites to simplify nested successor functions:
\begin{verbatim}
rw [two_eq_succ_one]
rw [add_succ]
rw [one_eq_succ_zero]
rw [add_succ]
rw [add_zero]
rw [four_eq_succ_three]
rw [three_eq_succ_two]
rw [two_eq_succ_one]
rw [one_eq_succ_zero]
rfl
\end{verbatim}
This level emphasized the importance of meticulous, step-by-step simplifications, especially when dealing with Peano arithmetic.

\subsubsection*{Comments and Questions}

How do the abstract rules in formal systems like the MU-puzzle translate into practical applications in software engineering? 

\subsection{Week 2}

\ldots

\subsection{Lessons from the Assignments}

Throughout the semester, I encountered various challenges and learning opportunities that contributed to my understanding of formal systems, logic, and Lean theorem proving. Here are the key lessons:

\subsection{Precision and Structure in Formal Systems}

The early weeks of the course, particularly Week 1, emphasized the precision required when working within formal systems. The MU-puzzle illustrated how even simple rules can lead to complex problem-solving scenarios, mirroring the need for exactness in Lean proofs. As I progressed through the levels in Lean, this precision became even more critical, particularly when dealing with nested functions and arithmetic expressions.

\subsection{The Art of Rewriting in Lean}

Rewriting is a fundamental tactic in Lean, as demonstrated in Levels 5-8. The ability to identify which parts of an expression to rewrite—and in what order—can make the difference between a successful proof and a failed one. This process is not just mechanical; it involves a deep understanding of the underlying logical structure and the relationships between different components of an expression.

\subsection{Conclusion}\label{conclusion}

This course provided a rigorous exploration of formal systems and Lean theorem proving, both of which are foundational to understanding logic and formal reasoning in computer science.

\section{Week 2}

\subsubsection{Lecture Content}

In Week 2, we delved deeper into the Natural Number Game (NNG) and focused on the Addition World. The lectures covered the fundamental properties of addition for natural numbers and introduced us to more advanced proof techniques in Lean.

Key topics included:
\begin{itemize}
    \item Commutativity and associativity of addition
    \item The role of zero in addition
    \item Inductive proofs for properties of addition
    \item Tactics for rewriting and simplifying expressions in Lean
\end{itemize}

\subsubsection{NNG Addition World Solutions}

\paragraph{Levels 1-3: Lean Proofs}

\begin{lstlisting}
-- Level 1
rw [add_zero]

-- Level 2
rw [add_succ]
rw [succ_add]

-- Level 3
rw [succ_add]
rw [add_succ]
\end{lstlisting}

\paragraph{Level 4: Mathematical Proof}

\textbf{Theorem:} For all natural numbers a and b, a + succ(b) = succ(a + b)

\textbf{Proof:}
\begin{align*}
a + \text{succ}(b) &= \text{succ}(a + b) \quad [\text{by definition of +}]
\end{align*}

\paragraph{Level 5: Mathematical Proof}

\textbf{Theorem:} For all natural numbers n, 0 + n = n

\textbf{Proof:} By induction on n.

Base case: n = 0
\begin{align*}
0 + 0 &= 0 \quad [\text{by definition of +}]
\end{align*}

Inductive step: Assume 0 + k = k for some k. We need to prove 0 + succ(k) = succ(k).
\begin{align*}
0 + \text{succ}(k) &= \text{succ}(0 + k) \quad [\text{by definition of +}] \\
&= \text{succ}(k) \quad [\text{by inductive hypothesis}]
\end{align*}

Therefore, by mathematical induction, 0 + n = n for all natural numbers n.

\subsubsection{Relationship between Lean Proof and Mathematical Proof}

Let's examine the relationship between the Lean proof and the mathematical proof for Level 5:

Lean proof:
\begin{lstlisting}[language=Lean]
induction n with d hd
· rw [add_zero]
  rfl
· rw [add_succ]
  rw [hd]
  rfl
\end{lstlisting}

The Lean proof closely mirrors the structure of the mathematical induction proof:

1. \texttt{induction n with d hd} corresponds to setting up the induction on \(n\), with \(d\) representing the inductive variable and \texttt{hd} the inductive hypothesis.

2. The base case \texttt{rw [add\_zero]} followed by \texttt{rfl} reflects the mathematical step \(0 + 0 = 0\).

3. In the inductive step, \texttt{rw [add\_succ]} corresponds to expanding \(0 + \text{succ}(d)\) to \(\text{succ}(0 + d)\).

4. \texttt{rw [hd]} applies the inductive hypothesis, similar to using \(0 + k = k\) in the mathematical proof.

5. Finally, \texttt{rfl} completes the proof by asserting that the equality is now trivial, just as we conclude in the mathematical proof.

This comparison demonstrates how the rigorous structure of mathematical induction is encoded in Lean's tactics, providing a formal, machine-checkable version of the traditional proof.

\subsubsection{Interesting Question}

How does the use of induction in proving properties of natural numbers relate to recursive definitions in programming languages? Can we draw parallels between mathematical induction and recursive algorithms?

\section{Week 3}
\subsection{Parsing and Context-Free Grammars}
\subsubsection{Lecture Content}
In Week 3, we explored the concepts of parsing and context-free grammars (CFGs). The lectures covered the following key topics:
\begin{itemize}
\item Translating concrete syntax into abstract syntax
\item The role of parsing in programming languages
\item Defining the concrete syntax of a calculator using a CFG
\item Writing a CFG using the Lark parser generator
\item Generating a parser in Python to translate concrete arithmetic expressions to abstract ones
\end{itemize}
\subsubsection{Homework Solutions}
\paragraph{Derivation Trees}
Using the provided context-free grammar, here are the derivation trees for the given strings:
2+1:
\begin{verbatim}
Exp
|
Exp '+' Exp1
|       |
Exp1     Exp2
|       |
Exp2   Integer
|       |
Integer    '1'
|
'2'
\end{verbatim}
1+23:
\begin{verbatim}
Exp
|
Exp '+' Exp1
|       |
Exp1   Exp1 '' Exp2
|       |       |
Exp2    Exp2   Integer
|       |       |
Integer  Integer   '3'
|       |
'1'    '2'
\end{verbatim}
1+(23):
\begin{verbatim}
Exp
|
Exp '+' Exp1
|       |
Exp1    Exp2
|       |
Exp2   '(' Exp ')'
|       |   |
Integer    Exp1 '' Exp2
|       |       |
'1'    Exp2   Integer
|       |
Integer    '3'
|
'2'
\end{verbatim}
(1+2)3:
\begin{verbatim}
Exp
|
Exp1 '' Exp2
|        |
Exp2    Integer
|        |
'(' Exp ')'  '3'
|
Exp '+' Exp1
|       |
Exp1     Exp2
|       |
Exp2   Integer
|       |
Integer    '2'
|
'1'
\end{verbatim}
1+23+45+6:
\begin{verbatim}
Exp
|
Exp '+' Exp1
|       |
Exp '+' Exp1 Exp2
|       |     |
Exp1 Exp1 '' Exp2 Integer
|     |       |     |
Exp2  Exp2   Integer '6'
|     |       |
Integer Integer   '5'
|     |
'1'  '2' '' Exp2
|
Exp2
|
Integer
|
'3' '+' Exp1
|
Exp1 '*' Exp2
|       |
Exp2   Integer
|       |
Integer    '4'
|
'3'
\end{verbatim}
\paragraph{Similarities and Differences between CFG and Algebraic Data Type}
The CFG and algebraic data type for expressions share some similarities:
\begin{itemize}
\item Both define the structure of valid expressions
\item Both capture the precedence of operations (e.g., multiplication before addition)
\item Both can be used to generate or recognize valid expressions
\end{itemize}
However, there are also some key differences:
\begin{itemize}
\item The CFG is used for parsing, i.e., translating concrete syntax (strings) into an abstract syntax tree (AST), while the algebraic data type directly defines the structure of the AST
\item The CFG is a set of production rules, while the algebraic data type is a type definition with constructors
\item The CFG can include redundant rules or ambiguity, while the algebraic data type is more precise and concise
\end{itemize}
\subsubsection{Interesting Questions}
\begin{itemize}
\item How can we extend the calculator CFG to handle more advanced features like variables, functions, or control structures?
\item What are some real-world applications of parsing beyond programming languages (e.g., natural language processing, data serialization formats)?
\item How do more advanced parsing techniques like parser combinators or parsing expression grammars compare to traditional CFG-based parsing?
\end{itemize}

\begin{thebibliography}{99}
\bibitem[BLA]{bla} Author, \href{https://en.wikipedia.org/wiki/LaTeX}{Title}, Publisher, Year.
\end{thebibliography}

\end{document}
